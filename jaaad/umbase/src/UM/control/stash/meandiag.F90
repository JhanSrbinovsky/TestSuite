#if defined(C84_1A)
! *****************************COPYRIGHT*******************************
! (C) Crown copyright Met Office. All rights reserved.
! For further details please refer to the file COPYRIGHT.txt
! which you should have received as part of this distribution.
! *****************************COPYRIGHT*******************************
!
!LL  Routine: MEANDIAG -------------------------------------------------
!LL
!LL  Purpose: Outputs mean diagnostic PPfiles from within the means
!LL           program.  Fields are generated by the normal operation of
!LL           the climate meaning system (ie. all fields in D1 except
!LL           integer and logical data are averaged).  Section 0 fields
!LL           and fields which can be derived from them by the PCR's
!LL           DYN_DIAG and PHY_DIAG (as used in sections 15/16 for
!LL           instantaneous diagnostics) are available to STASH as
!LL           section 21-24 diagnostics in this routine, but the UI
!LL           ensures that only spatial processing is requested and the
!LL           output is forced to go to the designated mean PPfile.  In
!LL           the case of the ocean model, there is no equivalent of
!LL           DYN_DIAG and PHY_DIAG so only "section 0" fields can be
!LL           processed (but now as sections 41-44).
!LL           Fields which were already processed by STASH, stored in D1
!LL           and then meaned further by the meaning system are only
!LL           extracted to the mean PPfile if the STASH usage profile of
!LL           the original diagnostic processing record so indicates.
!LL           This is determined by a loop over all STASH records with a
!LL           check on the STASH tag field, with a further loop over the
!LL           number of output levels associated with the STASH record.
!LL
!LL  Tested under compiler:   cft77
!LL  Tested under OS version: UNICOS 6.1.5A
!LL
!LL  Author:   T.C.Johns
!LL
!LL  Programming standard: UM Doc Paper 3, version 2 (7/9/90)
!LL
!LL  Logical components covered: C5
!LL
!LL  Project task: C5
!LL
!LL  External documentation:
!LL    UM Doc Paper C0 - The top-level control system
!LL    UM Doc Paper C5 - Calculation of means
!LL
!LL  -------------------------------------------------------------------
!*L  Interface and arguments: ------------------------------------------
!
      SUBROUTINE MEANDIAG (                                             &
#include "argd1.h"
#include "argduma.h"
#include "argsts.h"
#include "argptra.h"
#include "arglndm.h"
#include "arginfa.h"
#include "argppx.h"
     &           I_AO,MEANLEV,PP_LEN_MEAN,STEP_DUMPS,MEAN_PERIOD,       &
#if defined(MPP)
     &           MAX_SIZE,                                              &
#endif
     &           ICODE,CMESSAGE)
!
      Use field_buff_mod, Only :                                        &
     &    Attach_fxh,                                                   &
     &    Attach_ipplook
      IMPLICIT NONE
!
#include "parvars.h"
#include "cmaxsize.h"
#include "csubmodl.h"
#include "cintfa.h"
#include "typsize.h"
#include "typd1.h"
#include "typduma.h"
! Contains *CALL CPPXREF
#include "typsts.h"
#include "typptra.h"
#include "typlndm.h"
#include "typinfa.h"
#include "decomptp.h"
#include "comvgrid.h"

      INTEGER                                                           &
     &       I_AO,                                                      &
                               ! IN  Atmosphere/Ocean indicator
     &       MEANLEV,                                                   &
                               ! IN  Mean level indicator
     &       PP_LEN_MEAN,                                               &
                               ! IN  Number of fields in output PPfile
     &       STEP_DUMPS,                                                &
                               ! IN  Timestep in multiples of restart
!                              ! dump frequency.
     &       MEAN_PERIOD,                                               &
                               ! IN meaning frequency.
#if defined(MPP)
     &       MAX_SIZE,                                                  &
                               ! IN maximum dump field size
#endif
     &       ICODE             ! OUT return code; successful=0, error> 0
!
      CHARACTER*(80)                                                    &
     &       CMESSAGE          ! OUT Error message if ICODE > 0
!*
!
! Common blocks and parameters
!
#include "clookadd.h"
#include "stparam.h"
#include "chsunits.h"
#include "chistory.h"
#include "ccontrol.h"
#include "ctime.h"
#include "c_mdi.h"

! PPXREF lookup arrays
#include "ppxlook.h"

! Function definitions
      INTEGER  EXPPXI
!
! Dynamic allocated workspace
!
      INTEGER, DIMENSION(:), POINTER :: PP_FIXHD
      INTEGER, DIMENSION(:,:), POINTER :: PPLOOK
#if defined(MPP)
      REAL buf(MAX_SIZE)  ! I/O buffer space
!DIR$ CACHE_ALIGN buf
#endif
!
!dir$ cache_align pplook, pp_fixhd
#include "cntl_io.h"
!
      INTEGER IPPLOOK(LEN1_LOOKUP)          ! Copy of D1 field header
!      Local variables and arrays
!
      CHARACTER*14                                                      &
     &       PPNAME              ! Name of PPfile
      REAL                                                              &
     &       A_IO                ! IO error return code on BUFFER IO
      INTEGER                                                           &
     &       WORD_ADDRESS,                                              &
                                 ! IO word address on BUFFER IO
     &       LEN_IO,                                                    &
                                 ! IO transfer length on BUFFER IO
     &       NFTPIPE,                                                   &
                                 ! FORTRAN unit number for named pipe
     &       PPUNIT,                                                    &
                                 ! FORTRAN unit number for PPfile
     &       INDEXM,                                                    &
                                 ! Mean level index
     &       FIELD,                                                     &
                                 ! Index over field number in LOOKUP
     &       FIELD_ADDRESS,                                             &
                                 ! Address of field in D1
     &       FIELD_LENGTH,                                              &
                                 ! Length of single field
     &       BUFFER_LENGTH,                                             &
                                 ! Length of buffer for field
     &       IS,IM,                                                     &
                                 ! STASH section,item codes for field
     &       IE,                                                        &
                                 ! STLIST index over entries
     &       modl,                                                      &
                                 ! Int. model no. read from STASH record
     &       TAG,                                                       &
                                 ! STLIST tag used to identify field
     &       NROWS,                                                     &
                                 ! No of rows in field
     &       NCOLS,                                                     &
                                 ! No of columns in field
     &       NO,N_LEVS,                                                 &
                                 ! Bottom level and number of levels
     &       LEVEL,                                                     &
                                 ! Index over levels
     &       COMP_ACCRCY,                                               &
                                 ! Packing accracy
     &       LBTIM_IA,                                                  &
                                 ! Sampling period in hours for LBTIM
     &       LBTIM_IB,                                                  &
                                 ! Type of time field for LBTIM
     &       IWA,                                                       &
                                 ! Word address used in SETPOS
     &       ICURRLL,                                                   &
                                 ! Current position in PP LOOKUP table
     &       ICURRL1,                                                   &
                                 ! Current position in PP LOOKUP table
     &       LEN_BUF_WORDS,                                             &
                                 ! NUM_WORDS rounded to 512
     &       NUM_WORDS,                                                 &
                                 ! Number of words reqd to hold the data
     &       I,                                                         &
                                 ! Loop index
     &       NF,                                                        &
                                  ! No of field
     &       START_DAY,                                                 &
                                 ! Start time for mean period (days)
     &       START_SECOND,                                              &
                                 ! Start time for mean period (seconds)
     &       PERIOD_DAYS,                                               &
                                 ! Start time for mean period (days)
     &       PERIOD_SECS,                                               &
                                 ! Start time for mean period (seconds)
     &       START_TIME(7)                                              &
                                 ! Start time for mean period(date/time)
     &      ,im_ident                                                   &
                                 !  Internal Model Identifier
     &      ,im_index                                                   &
                                 !  Internal Model Index for stash
     &      ,LEN_PPNAME                                                 &
     &      ,PACKING_TYPE                                               &
                                ! 0=unpacked, 1=WGDOS, 3=GRIB
     &      ,GRIB_PACKING                                               &
                                ! packing profile used for grib packing
     &      ,D1POS                                                      &
                                ! Position of info in D1_ADDR array
     &      ,orig_decomp                                                &
                                ! Used to check for change in
     &      ,new_decomp         ! decomposition
      INTEGER LEN_EXTRA ! IN size of expected extra data
      INTEGER SROW_OUT  ! Dummy - 1st southern row to output
      INTEGER WCOL_OUT  ! Dummy - 1st western column to output
      LOGICAL                                                           &
     &       PACKING,                                                   &
                                 ! Switch to enable optional packing
     &       LPACKFIELD                                                 &
                                ! Per-field packing indicator
     &       ,GRIB_OUT          ! .True. if output to be in grib

#if defined(MPP)
      INTEGER                                                           &
     &  GR                                                              &
                                ! Gridtype code
     &, GLOBAL_PPHORIZ_OUT                                              &
                                ! Size of global field
     &, info                                                            &
                                ! Unused arg in GCOM calls
     &, LOCAL_LEN                                                       &
                                ! Length of field:
                                ! from GENERAL_GATHER_FIELD
     &, SUBM                    ! Submodel number for internal model id

      REAL A                    ! To hold return code
                                ! from GENERAL_GATHER_FIELD
#endif


      INTEGER grid_type ! grid type - for extra data processing
      INTEGER fld_type  ! field type - for extra data processing
      INTEGER EXTRA_VAR_DATA ! Length of variable grid data
      INTEGER GET_FLD_TYPE ! Function
      INTEGER IERR  ! GCOM returns
      INTEGER IPPVAL
      REAL    RPPVAL
      EQUIVALENCE (IPPVAL,RPPVAL)
      INTEGER, PARAMETER :: CURRENT_IO_PE = 0
!
      im_ident = I_AO
      im_index = internal_model_index(im_ident)

!L----------------------------------------------------------------------
!L 1. Initialise output ppfile for mean data at level MEANLEV.
!L    OPEN the file ready to receive mean PPfields from STASH.
!L
! DEPENDS ON: ppctl_init_climate_means
      CALL PPCTL_INIT_CLIMATE_MEANS (          &
#include "argduma.h"
           I_AO,MEANLEV,PPNAME,ICODE,CMESSAGE)
      IF (ICODE >  0) GOTO 999
      IF (I_AO == 1 .or. I_AO == 2) THEN
        PPUNIT = FT_MEANim(I_AO)
      ELSE
        ICODE = 311
        CMESSAGE='MEANDIAG : I_AO has invalid value'
        GOTO 999
      ENDIF
      LEN_PPNAME=LEN(PPNAME)
! DEPENDS ON: file_open
      CALL FILE_OPEN(PPUNIT,PPNAME,LEN_PPNAME,1,1,ICODE)
      IF (ICODE /= 0) GOTO 999
!L----------------------------------------------------------------------
!L 2. Extract mean fields from mean dump fields in D1, and append to
!L    mean PPfile.  The fields dealt with in this section are the
!L    prognostic fields as meaned by the climate meaning system, plus
!L    fields derived from them (in the case of the atmosphere).
!L    The STASH section number depends on the mean level and whether
!L    atmosphere or ocean.  Different sets of fields can be requested
!L    from different mean periods.
!L
#if defined(ATMOS)
      IF (I_AO == 1) THEN
! DEPENDS ON: st_mean
        CALL ST_MEAN (                                                  &
#include "argd1.h"
#include "argduma.h"
#include "argsts.h"
#include "argptra.h"
#include "arglndm.h"
#include "argppx.h"
     &                20+MEANLEV,STASH_MAXLEN(20+MEANLEV,im_index),     &
     &                ICODE,CMESSAGE)
      ENDIF
#endif
      IF (ICODE >  0) GOTO 999
!L----------------------------------------------------------------------
!L 3. Loop over STASHlist entries and extract tagged fields which are
!L already processed into D1 by STASH to the mean PP file
!L
!L 3.1 Buffer in PPfile fixed length header to get address of lookup
!L
      ALLOCATE(PP_FIXHD(LEN_FIXHD))
      CALL ATTACH_FXH(PP_FIXHD, PPUNIT)
      WORD_ADDRESS=PP_FIXHD(150)-1
!L
!L 3.2 Buffer in PPfile lookup header to PPLOOK work array
!L
       ALLOCATE(PPLOOK(LEN1_LOOKUP,PP_LEN_MEAN))

       IF (MYPE == CURRENT_IO_PE) THEN
          CALL ATTACH_IPPLOOK(PPLOOK, PPUNIT)
       END IF

! broadcast the lookup table to other PEs
       CALL GC_IBCAST(74,LEN1_LOOKUP*PP_LEN_MEAN,CURRENT_IO_PE,NPROC,   &
     &                IERR,PPLOOK)

!L
!L 3.3 Initialise output address and LOOKUP entry number in the PPfile
!L
!
      ICURRLL=FT_LASTFIELD(PPUNIT)
      ICURRL1=FT_LASTFIELD(PPUNIT)  ! required if grib output
      IF (ICURRLL == 0) THEN  ! this is the first field
        IWA=PP_FIXHD(150)-1+LEN1_LOOKUP*PP_LEN_MEAN
! round address up to um_sector_size-words
        IWA=((IWA+um_sector_size-1)/um_sector_size)*um_sector_size
      ELSE                    ! append to the previous field
        IWA=PPLOOK(LBEGIN,ICURRLL)+PPLOOK(LBNREC,ICURRLL)
      ENDIF

! Use PP_PACK_CODE to set packing type and GRIB flag
! For GRB output reset PP_PACK_CODE to give packing profile.
      IF (PP_PACK_CODE(PPUNIT) >= 100) THEN
        GRIB_OUT=.TRUE.
        PP_PACK_CODE(PPUNIT)=PP_PACK_CODE(PPUNIT)-100
        GRIB_PACKING=PP_PACK_CODE(PPUNIT)
        PACKING_TYPE=3
      ELSE
        GRIB_OUT=.FALSE.
      ENDIF
!
! Set packing switch : profile 0 means no packing
!
      IF (PP_PACK_CODE(PPUNIT) == 0) THEN
        PACKING=.FALSE.
      ELSE
        PACKING=.TRUE.
      ENDIF
!L
!L 3.4 Start loop over STASHlist entries.
!L
!L 3.41 Check if job exceeds the UM field limit
      NF=0
      DO IE=1,TOTITEMS
        TAG=STLIST(st_macrotag, ie)/1000
        IF (MOD(TAG/(2**(MEANLEV-1)),2)  == 1) THEN
          IF ((STLIST(st_input_bottom,IE) == st_special_code).or.       &
     &         (STLIST(st_gridpoint_code,IE) <  vert_mean_top .AND.     &
     &          STLIST(st_gridpoint_code,IE) >  vert_mean_base).or.     &
     &         (STLIST(st_series_ptr,IE) >  0)) THEN
            N_LEVS=1
          ELSE
            NO=STLIST(st_output_bottom,IE)
            IF (NO <  0) THEN
              N_LEVS=STASH_LEVELS(1,-NO)
            ELSE
              N_LEVS=STLIST(st_output_top,IE)-                          &
     &               STLIST(st_output_bottom,IE)+1
            ENDIF
          ENDIF
          IF (STLIST(st_pseudo_out,IE) >  0) THEN
            NO=STLIST(st_pseudo_out,IE)
            N_LEVS=N_LEVS*STASH_PSEUDO_LEVELS(1,NO)
          ENDIF
          NF=NF+N_LEVS
        ENDIF
      ENDDO
      IF (NF >  PP_LEN_MEAN) THEN
        WRITE(6,*)'ERROR: UM limit of ',pp_len_mean,                    &
     &            ' fields exceed'
        WRITE(6,*)'Use VERIFY DIAGNOSTICS in UMUI'
        WRITE(6,*)'See HELP in UMUI STASH panel'
        ICODE=4
        CMESSAGE=' MEANDIA2: Exceed fields limit'
        GOTO 999
      ENDIF
! Note in the case of grib output this loop is used to set up pp headers
! only
!
      DO IE =1,TOTITEMS
        modl=STLIST(st_model_code  ,IE)
        IS  =STLIST(st_sect_no_code,IE)
        IM  =STLIST(st_item_code   ,IE)
        TAG =STLIST(st_macrotag    ,IE)/1000
        IF ( (MOD(TAG/(2**(MEANLEV-1)),2)  == 1) .AND.                  &
     &       (I_AO == modl) ) THEN


! The Tag matches this mean period and the item is in this dump  .
!
! Determine the number of output levels and starting LOOKUP header
! (Number of levels now includes possible pseudo_levels)
! NB: Note that vertical means (single output level) are a special case
!     as are timeseries (also single output level)
!
          IF (STLIST(st_input_bottom,IE) == st_special_code) THEN
            N_LEVS=1                       ! Output is a special level
          ELSEIF (STLIST(st_gridpoint_code,IE) <  vert_mean_top .AND.   &
     &            STLIST(st_gridpoint_code,IE) >  vert_mean_base) THEN
            N_LEVS=1                       ! Output is a vertical mean
          ELSEIF (STLIST(st_series_ptr,IE) >  0) THEN
            N_LEVS=1                       ! Output is a timeseries
          ELSE
            NO=STLIST(st_output_bottom,IE)
            IF (NO <  0) THEN              ! Output is level list
              N_LEVS=STASH_LEVELS(1,-NO)
            ELSE                           ! Output is level range
              N_LEVS=STLIST(st_output_top,IE)-                          &
     &               STLIST(st_output_bottom,IE)+1
            ENDIF
          ENDIF
          IF (STLIST(st_pseudo_out,IE) >  0) THEN
            NO=STLIST(st_pseudo_out,IE)
            N_LEVS=N_LEVS*STASH_PSEUDO_LEVELS(1,NO)
          ENDIF
          FIELD=STLIST(st_lookup_ptr,IE)
#if defined(MPP)
! Address of distributed field in D1
          FIELD_ADDRESS=stlist(st_output_addr,IE)
#endif
!
! Loop over the number of output levels
          DO LEVEL=1,N_LEVS
! Copy LOOKUP header for field from A_LOOKUP or O_LOOKUP to work header
#if defined(ATMOS)
            IF (I_AO == 1) THEN
              DO I=1,LEN1_LOOKUP
                IPPLOOK(I)=A_LOOKUP(I,FIELD+LEVEL-1)
              ENDDO
            ENDIF
#endif
! Field and buffer sizes, and field address in D1
            FIELD_LENGTH =IPPLOOK(LBLREC)
#if defined(MPP)
            IF (FIELD_LENGTH  >   MAX_SIZE) THEN
              WRITE(6,*) 'Error in MEANDIAG : MAX_SIZE too small.'
              WRITE(6,*) 'MAX_SIZE= ',MAX_SIZE
              WRITE(6,*) 'FIELD_LENGTH= ',FIELD_LENGTH
              ICODE=1
              CMESSAGE='MEANDIAG: MAX_SIZE too small'
              GOTO 999
            ENDIF
#endif
            NROWS=IPPLOOK(LBROW)
            NCOLS=IPPLOOK(LBNPT)
#if !defined(MPP)
            FIELD_ADDRESS=IPPLOOK(NADDR)
#endif
            BUFFER_LENGTH=((FIELD_LENGTH+um_sector_size-1)/             &
     &       um_sector_size)*um_sector_size
! Section/Item codes
            IS=IPPLOOK(ITEM_CODE)/1000
            IM=IPPLOOK(ITEM_CODE)-1000*IS
      ! Ensure LEN_EXTRA is initialised
      LEN_EXTRA = IPPLOOK(LBEXT)

      SROW_OUT = 1
      WCOL_OUT = 1

      VAR_GRID_TYPE = 0
      EXTRA_VAR_DATA = 0
      ! If we're dealing with an ocean model which uses variable
      ! grid spacing.
      IF ((X_VAR_GRID.OR.Y_VAR_GRID).AND.(I_AO == 2)) THEN

         ! Find the grid type
! DEPENDS ON: exppxi
         grid_type = EXPPXI( im_ident, IS, IM, ppx_grid_type,           &
#include "argppx.h"
     &             icode, cmessage)

         ! Find the field type
! DEPENDS ON: get_fld_type
         fld_type=GET_FLD_TYPE(grid_type)


         ! Each dimesion has 3 lots of extra grid data -
         ! grid coordinates, lower and upper box boundaries.
         ! May need to incorporate test to exclude certain
         ! grid types (eg LBCs) if they're not appropriate.
         IF (fld_type == fld_type_p) THEN
            VAR_GRID_TYPE = 1 ! It's a T field
            IF (X_VAR_GRID) EXTRA_VAR_DATA =                            &
     &                      EXTRA_VAR_DATA + (3*(NCOLS+1))
            IF (Y_VAR_GRID) EXTRA_VAR_DATA =                            &
     &                      EXTRA_VAR_DATA + (3*(NROWS+1))
         ELSEIF (fld_type == fld_type_u.OR.                             &
     &           fld_type == fld_type_v) THEN
            VAR_GRID_TYPE = 2 ! It's a U,V field
            IF (X_VAR_GRID) EXTRA_VAR_DATA =                            &
     &                      EXTRA_VAR_DATA + (3*(NCOLS+1))
            IF (Y_VAR_GRID) EXTRA_VAR_DATA =                            &
     &                      EXTRA_VAR_DATA + (3*(NROWS+1))
         ENDIF

         LEN_EXTRA = EXTRA_VAR_DATA

      ENDIF
! Packing accuracy of the data :-
! NB: Presence of extra data disables packing for this field
            IF (PACKING.AND.(IPPLOOK(LBEXT) <= 0)) THEN
               COMP_ACCRCY=                                             &
! DEPENDS ON: exppxi
     &    EXPPXI(modl,IS,IM,ppx_packing_acc+PP_PACK_CODE(PPUNIT)-1,     &
#include "argppx.h"
     &                                 ICODE,CMESSAGE)
              LPACKFIELD=.TRUE.
            ELSE
              COMP_ACCRCY=-99
              LPACKFIELD=.FALSE.
            ENDIF
            IF (.NOT.GRIB_OUT) THEN
#if defined(MPP)
              IF(mype == 0)THEN
                CALL SETPOS_single(PPUNIT,IWA,ICODE)
              ENDIF
              SUBM=SUBMODEL_FOR_SM(im_ident)
!             Reuse decomposition type if it is unchanged. Otherwise
!             change it to the new type.
              D1POS=STLIST(st_d1pos,IE)
              orig_decomp=current_decomp_type
              new_decomp=orig_decomp

              IF ((D1_ADDR(d1_imodl,D1POS,SUBM)  ==  ATMOS_IM) .AND.    &
     &          (orig_decomp  /=  decomp_standard_atmos)) THEN

                new_decomp=decomp_standard_atmos

              ELSEIF ((D1_ADDR(d1_imodl,D1POS,SUBM)  ==  OCEAN_IM) .AND.&
     &            (D1_ADDR(d1_object_type,D1POS,SUBM)  ==  prognostic)  &
     &            .AND. (orig_decomp  /=  decomp_standard_ocean)) THEN

                new_decomp=decomp_standard_ocean

              ELSEIF ((D1_ADDR(d1_imodl,D1POS,SUBM)  ==  OCEAN_IM) .AND.&
     &            (D1_ADDR(d1_object_type,D1POS,SUBM)  /=  prognostic)  &
     &            .AND. (orig_decomp  /=  decomp_nowrap_ocean)) THEN

                new_decomp=decomp_nowrap_ocean

              ENDIF

              IF (new_decomp  /=  orig_decomp) THEN
                icode=0
! DEPENDS ON: change_decomposition
                CALL CHANGE_DECOMPOSITION(new_decomp,icode)

                IF (icode  /=  0) THEN
                  IF (mype  ==  0) THEN
                    WRITE(6,*) 'ERROR : MEAN_DIAG'
                    WRITE(6,*) 'Failed to change decomposition to ',    &
     &                new_decomp
                    WRITE(6,*) 'Field M,S,I ',                          &
     &                D1_ADDR(d1_imodl,D1POS,SUBM),                     &
     &                D1_ADDR(d1_section,D1POS,SUBM),                   &
     &                D1_ADDR(d1_item,D1POS,SUBM)
                  ENDIF
                  CMESSAGE='MEANDIA2 : Failed to change decomposition'
                  GOTO 999
                ENDIF

              ENDIF
!             Gather full field to PE0
! DEPENDS ON: general_gather_field
              CALL GENERAL_GATHER_FIELD(D1(FIELD_ADDRESS),buf,LOCAL_LEN,&
     &          FIELD_LENGTH,1,D1_ADDR(1,STLIST(st_d1pos,IE),SUBM),0,   &
     &          ICODE,CMESSAGE)
              IF (ICODE  ==  1) THEN
                WRITE(6,*)'MEANDIA2: Field number ',IS,                 &
     &            'with dimensions ', NCOLS,' x ',                      &
     &            NROWS,' and gridtype ',                               &
     &            D1_ADDR(d1_grid_type,STLIST(st_d1pos,IE),SUBM),       &
     &            'was unrecognized and not gathered.'
                CMESSAGE='MEANDIA2: Unrecognized field on write'
                GOTO 999
              ELSEIF (ICODE  /=  0) THEN
                GOTO 999
              ENDIF
              ICODE=0
              IF (mype  ==  0) THEN
! DEPENDS ON: pp_file
                CALL PP_FILE(BUF,BUFFER_LENGTH,NUM_WORDS,RMDI,          &
     &            COMP_ACCRCY,FIELD_LENGTH,PPUNIT,IWA,NCOLS,NROWS,      &
     &            PACKING,im_ident,LRLE,                                &
     &            PACKING_TYPE,0                                        &
     &           ,LEN_EXTRA,SROW_OUT,WCOL_OUT,ICODE,CMESSAGE)
              ENDIF
              CALL GC_ISUM(1, nproc, info, icode)

              IF(ICODE >  0) THEN
                CMESSAGE=                                               &
     &            'MEANDIA2: Error in PP_FILE - see ICODE for item'
                ICODE=1000*IS+IM
                GOTO 999
              ENDIF

! Increment field address to point to next level if there is one.
              FIELD_ADDRESS=FIELD_ADDRESS+LOCAL_LEN
#endif
            ENDIF
! Copy work header for field to next PPfile header
            ICURRLL=ICURRLL+1                           ! Next field
            DO I=1,LEN1_LOOKUP
              PPLOOK(I,ICURRLL)=IPPLOOK(I)
            ENDDO
! Reset PPheader words that differ from dump LOOKUP header conventions
            PPLOOK(LBREL,ICURRLL)=2                     ! PP release no
            PPLOOK(DATA_TYPE,ICURRLL)=1                 ! Real field
            IF (PACKING_TYPE == 1) THEN
              PPLOOK(LBPACK,ICURRLL)=02001              ! WGDOS packed
            ELSE IF (PACKING_TYPE == 3) THEN
              PPLOOK(LBPACK,ICURRLL)=02003              ! GRIB packed
            ELSE IF (PACKING_TYPE == 4) THEN
              PPLOOK(LBPACK,ICURRLL)=02004   ! Run length encoded
            ELSE
              PPLOOK(LBPACK,ICURRLL)=02000              ! Unpacked
            ENDIF
            RPPVAL = COMP_ACCRCY                        ! Accuracy
            PPLOOK(BACC,ICURRLL) = IPPVAL
            RPPVAL=RMDI                                 ! Missing data
            PPLOOK(BMDI,ICURRLL)=IPPVAL
            RPPVAL = 1.0                                ! MKS scale fac
            PPLOOK(BMKS,ICURRLL)=IPPVAL
            IF (.NOT.GRIB_OUT) THEN
              PPLOOK(LBLREC,ICURRLL)=NUM_WORDS         ! Packed length
              PPLOOK(LBNREC,ICURRLL)=((NUM_WORDS+um_sector_size-1)/     &
     &         um_sector_size)*um_sector_size
!                                                      ! Rounded length
              PPLOOK(LBEGIN,ICURRLL)=IWA                 ! Address
              PPLOOK(NADDR,ICURRLL)=IWA                  ! Address
              IWA=IWA+PPLOOK(LBNREC,ICURRLL)             ! Next address
            ENDIF
          ENDDO  ! End of loop over levels
        ENDIF
!
      ENDDO      ! End of loop over STASHlist entries
! Update FT_LASTFIELD
      FT_LASTFIELD(PPUNIT)=ICURRLL
!L----------------------------------------------------------------------
!L 4.  Finally loop over PP headers and set correct timestamps for the
!L     mean period concerned, and also reset LBTIM and LBPROC codes to
!L     reflect the mean period for the individual fields.
!L     NB: This loop deals with fields from both sections 2 and 3 above.
!L
!L 4.1 Calculate start time of meaning period from current time
!L
! DEPENDS ON: time2sec
      CALL TIME2SEC(I_YEAR,I_MONTH,I_DAY,I_HOUR,I_MINUTE,I_SECOND,      &
     &              BASIS_TIME_DAYS,BASIS_TIME_SECS,                    &
     &              START_DAY,START_SECOND,LCAL360)
!
      I=1
      IF (I_AO == 1 .or. I_AO == 2) THEN
        DO INDEXM=1,MEANLEV
          I=I*MEANFREQim(INDEXM,I_AO)
        ENDDO
! DEPENDS ON: stp2time
        CALL STP2TIME(I*DUMPFREQim(I_AO),                               &
     &        STEPS_PER_PERIODim(I_AO),SECS_PER_PERIODim(I_AO),         &
     &                PERIOD_DAYS,PERIOD_SECS)
      ELSE
        ICODE=312
        CMESSAGE='MEANDIAG : I_AO has invalid value'
        GOTO 999
      ENDIF
      START_SECOND=START_SECOND - PERIOD_SECS
      START_DAY   =START_DAY    - PERIOD_DAYS
!
! Note: START_TIME(6) is set to Day Number, not seconds
! DEPENDS ON: sec2time
      CALL SEC2TIME(START_DAY,START_SECOND,                             &
     &              BASIS_TIME_DAYS,BASIS_TIME_SECS,                    &
     &              START_TIME(1),START_TIME(2),START_TIME(3),          &
     &              START_TIME(4),START_TIME(5),START_TIME(7),          &
     &              START_TIME(6),LCAL360)
!L
!L 4.2 Set start and end times in mean PP headers from START_TIME
!L     and current time from CTIME.
!L     Recalculate LBTIM and LBPROC if necessary.
!L
      DO INDEXM=1,FT_LASTFIELD(PPUNIT)
!L    Update YR, MON, DAT, DAY to start and end of mean period
        PPLOOK(LBYR ,INDEXM)=START_TIME(LBYR)
        PPLOOK(LBMON ,INDEXM)=START_TIME(LBMON)
        PPLOOK(LBDAT ,INDEXM)=START_TIME(LBDAT)
        PPLOOK(LBDAY ,INDEXM)=START_TIME(LBDAY)
        PPLOOK(LBYRD ,INDEXM)=I_YEAR
        PPLOOK(LBMOND,INDEXM)=I_MONTH
        PPLOOK(LBDATD,INDEXM)=I_DAY
        PPLOOK(LBDAYD,INDEXM)=I_DAY_NUMBER
!L    Decode LBTIM IA and IB elements
        LBTIM_IA=PPLOOK(LBTIM,INDEXM)/100                ! Sample period
        LBTIM_IB=(PPLOOK(LBTIM,INDEXM)-(LBTIM_IA*100))/10 ! Time type
!L    Update HR and MIN to the start and end of the mean period
!L    unless IA and IB indicate a mean sampled at a particular time
!L    of day (assumed to represent part of a mean diurnal cycle, say),
!L    in which case the original starting offset time is
!L    retained for both the starting and ending time of day.
!L    Note: This special case is required to generate the distinguishable
!L    PP headers in the case of mean diurnal-cycle type diagnostics.
!L    It is not an ideal general solution, and may need reassessment
!L    at some time in the future.
        IF ((LBTIM_IA == 24).AND.(LBTIM_IB == 2)) THEN
          PPLOOK(LBHRD ,INDEXM)=PPLOOK(LBHR ,INDEXM)
          PPLOOK(LBMIND ,INDEXM)=PPLOOK(LBMIN ,INDEXM)
        ELSE
          PPLOOK(LBHR ,INDEXM)=START_TIME(LBHR)
          PPLOOK(LBMIN ,INDEXM)=START_TIME(LBMIN)
          PPLOOK(LBHRD ,INDEXM)=I_HOUR
          PPLOOK(LBMIND,INDEXM)=I_MINUTE
        END IF
        IF (lclimrealyr) then      ! real-period means always start
          PPLOOK(LBDAT,INDEXM)=1   ! on 1st of month
          if (PPLOOK(LBMON,INDEXM)  ==  1 .and.                         &
     &        PPLOOK(LBMOND,INDEXM)  ==  3) then
            PPLOOK(LBMON,INDEXM)=2 ! correct start month for Feb mean
          endif
        ENDIF
!
        IF (LBTIM_IA == 0) THEN                     ! Reset to dump
          LBTIM_IA = (DUMPFREQim(I_AO)*SECS_PER_PERIODim(I_AO))/        &
     &               (STEPS_PER_PERIODim(I_AO)*3600)
        ENDIF
#if defined(ATMOS)
        IF (I_AO == 1)                                                  &
     &    PPLOOK(LBTIM,INDEXM)=A_FIXHD(8)+20+                           &
                                                     ! Calendar+20+
     &                        100*LBTIM_IA          ! 100*sample_prd
#endif
!
        IF (MOD(PPLOOK(LBPROC,INDEXM)/128,2) == 0)                      &
                                                       ! not a mean
     &    PPLOOK(LBPROC,INDEXM)=PPLOOK(LBPROC,INDEXM)+128
      ENDDO
! --------------------------------------------------------------------
!  4.2A Section to output fields in grib code
!  NOTE - pp headers must be correct in everything except field lengths
!         before call to GRIB_FILE

      IF (GRIB_OUT) THEN

!L  loop over STASHlist entries.
!L
        DO IE  =1,TOTITEMS
          modl =STLIST(st_model_code  ,IE)
          IS   =STLIST(st_sect_no_code,IE)
          IM   =STLIST(st_item_code   ,IE)
          TAG  =STLIST(st_macrotag    ,IE)/1000
          IF ( (MOD(TAG/(2**(MEANLEV-1)),2) == 1) .AND.                 &
     &                               (I_AO == modl) ) THEN
! The Tag matches this mean period and the item is in this dump  .
!
! Determine the number of output levels and starting LOOKUP header
! (Number of levels now includes possible pseudo_levels)
! NB: Note that vertical means (single output level) are a special case
!     as are timeseries (also single output level)
!
           IF (STLIST(st_input_bottom,IE) == st_special_code) THEN
            N_LEVS=1                       ! Output is a special level
           ELSEIF (STLIST(st_gridpoint_code,IE) <  vert_mean_top .AND.  &
     &            STLIST(st_gridpoint_code,IE) >  vert_mean_base) THEN
            N_LEVS=1                       ! Output is a vertical mean
           ELSEIF (STLIST(st_series_ptr,IE) >  0) THEN
            N_LEVS=1                       ! Output is a timeseries
           ELSE
            NO=STLIST(st_output_bottom,IE)
            IF (NO <  0) THEN              ! Output is level list
              N_LEVS=STASH_LEVELS(1,-NO)
            ELSE                           ! Output is level range
              N_LEVS=STLIST(st_output_top,IE)-                          &
     &               STLIST(st_output_bottom,IE)+1
            ENDIF
           ENDIF
           IF (STLIST(st_pseudo_out,IE) >  0) THEN
            NO=STLIST(st_pseudo_out,IE)
            N_LEVS=N_LEVS*STASH_PSEUDO_LEVELS(1,NO)
           ENDIF
           FIELD=STLIST(st_lookup_ptr,IE)
#if defined(MPP)
! Address of distributed field in D1
           FIELD_ADDRESS=stlist(st_output_addr,IE)
#endif
!
! Loop over the number of output levels
           DO LEVEL=1,N_LEVS
! Copy  header for field ready to extract address information
            ICURRL1=ICURRL1+1                           ! Next field
            DO I=1,LEN1_LOOKUP
              IPPLOOK(I)=PPLOOK(I,ICURRL1)
            ENDDO
! Field and buffer sizes, and field address in D1
            FIELD_LENGTH =IPPLOOK(LBLREC)
            BUFFER_LENGTH=((FIELD_LENGTH+um_sector_size-1)/             &
     &       um_sector_size)*um_sector_size
#if !defined(MPP)
            FIELD_ADDRESS=IPPLOOK(NADDR)
#endif
! Section/Item codes
            IS=IPPLOOK(ITEM_CODE)/1000
            IM=IPPLOOK(ITEM_CODE)-1000*IS
! Packing accuracy of the data :-
! NB: Presence of extra data disables packing for this field
            IF (PACKING.AND.(IPPLOOK(LBEXT) <= 0)) THEN
              COMP_ACCRCY=                                              &
! DEPENDS ON: exppxi
     &     EXPPXI(modl,IS,IM,ppx_packing_acc+PP_PACK_CODE(PPUNIT)-1,    &
#include "argppx.h"
     &                                 ICODE,CMESSAGE)
              LPACKFIELD=.TRUE.
            ELSE
              COMP_ACCRCY=-99
              LPACKFIELD=.FALSE.
            ENDIF
#if defined(MPP)
              IF(mype == 0)THEN
                CALL SETPOS_single(PPUNIT,IWA,ICODE)
              ENDIF
              SUBM=SUBMODEL_FOR_SM(im_ident)
!             Check that decomposition type is up to date.
              D1POS=STLIST(st_d1pos,IE)
              orig_decomp=current_decomp_type
              new_decomp=orig_decomp

              IF ((D1_ADDR(d1_imodl,D1POS,SUBM)  ==  ATMOS_IM) .AND.    &
     &          (orig_decomp  /=  decomp_standard_atmos)) THEN

                new_decomp=decomp_standard_atmos

              ELSEIF ((D1_ADDR(d1_imodl,D1POS,SUBM)  ==  OCEAN_IM) .AND.&
     &            (D1_ADDR(d1_object_type,D1POS,SUBM)  ==  prognostic)  &
     &            .AND. (orig_decomp  /=  decomp_standard_ocean)) THEN

                new_decomp=decomp_standard_ocean

              ELSEIF ((D1_ADDR(d1_imodl,D1POS,SUBM)  ==  OCEAN_IM) .AND.&
     &            (D1_ADDR(d1_object_type,D1POS,SUBM)  /=  prognostic)  &
     &            .AND. (orig_decomp  /=  decomp_nowrap_ocean)) THEN

                new_decomp=decomp_nowrap_ocean

              ENDIF

              IF (new_decomp  /=  orig_decomp) THEN

                icode=0
! DEPENDS ON: change_decomposition
                CALL CHANGE_DECOMPOSITION(new_decomp,icode)

                IF (icode  /=  0) THEN
                  IF (mype  ==  0) THEN
                    WRITE(6,*) 'ERROR : MEAN_DIAG'
                    WRITE(6,*) 'Failed to change decomposition to ',    &
     &                new_decomp
                    WRITE(6,*) 'Field M,S,I ',                          &
     &                D1_ADDR(d1_imodl,D1POS,SUBM),                     &
     &                D1_ADDR(d1_section,D1POS,SUBM),                   &
     &                D1_ADDR(d1_item,D1POS,SUBM)
                  ENDIF
                  CMESSAGE='MEANDIA2 : Failed to change decomposition'
                  GOTO 999
                ENDIF

              ENDIF
!             Gather full field to PE0
! DEPENDS ON: general_gather_field
              CALL GENERAL_GATHER_FIELD(D1(FIELD_ADDRESS),buf,LOCAL_LEN,&
     &          FIELD_LENGTH,1,D1_ADDR(1,STLIST(st_d1pos,IE),SUBM),0,   &
     &          ICODE,CMESSAGE)
              IF (ICODE  ==  1) THEN
                WRITE(6,*)'MEANDIA2: Field number ',IS,                 &
     &            'with dimensions ', NCOLS,' x ',                      &
     &            NROWS,' and gridtype ',                               &
     &            D1_ADDR(d1_grid_type,STLIST(st_d1pos,IE),SUBM),       &
     &            'was unrecognized and not gathered.'
                CMESSAGE='MEANDIA2: Unrecognized field on write'
                GOTO 999
              ELSEIF (ICODE  /=  0) THEN
                GOTO 999
              ENDIF
              IF (mype  ==  0) THEN
! DEPENDS ON: grib_file
                CALL GRIB_FILE(LEN1_LOOKUP,PP_LEN_MEAN,PPLOOK,PPLOOK,   &
     &            ICURRL1,BUF,FIELD_LENGTH,                             &
     &            BUFFER_LENGTH,NUM_WORDS,PPUNIT,IWA,                   &
     &            GRIB_PACKING,ICODE,CMESSAGE)
              ENDIF

              CALL GC_IBCAST(999,1,0,nproc,info,ICODE)
              IF(ICODE >  0) THEN
                CMESSAGE=                                               &
     &    'MEANDIA2: Error in GRIB_FILE - see ICODE for item'
                ICODE=1000*IS+IM
                GOTO 999
              ENDIF
              IWA=IWA+PPLOOK(LBNREC,ICURRL1) ! Next address
#else
! Output the field from D1 to the PPfile with the requisite packing
! DEPENDS ON: grib_file
            CALL GRIB_FILE(LEN1_LOOKUP,PP_LEN_MEAN,PPLOOK,PPLOOK,       &
     &                     ICURRL1,D1(FIELD_ADDRESS),FIELD_LENGTH,      &
     &                     BUFFER_LENGTH,NUM_WORDS,PPUNIT,IWA,          &
     &                     GRIB_PACKING,ICODE,CMESSAGE)
            IF(ICODE >  0) THEN
            CMESSAGE='MEANDIA1: Error in GRIB_FILE - see ICODE for item'
              ICODE=1000*IS+IM
              GOTO 999
            ENDIF
            IWA=IWA+PPLOOK(LBNREC,ICURRL1)              ! Next address
#endif
           ENDDO  ! End of loop over levels
          ENDIF
!
        ENDDO      ! End of loop over STASHlist entries

! reset PP_PACK_CODE for future use

        PP_PACK_CODE(PPUNIT)=PP_PACK_CODE(PPUNIT)+100
      ENDIF
! --------------------------------------------------------------------
!L
!L 4.3 Buffer LOOKUP headers from work array back to file and close it
!L
! DEPENDS ON: setpos
      CALL SETPOS(PPUNIT,WORD_ADDRESS,ICODE)
! DEPENDS ON: buffout
      CALL BUFFOUT(PPUNIT,PPLOOK(1,1),LEN1_LOOKUP*PP_LEN_MEAN,LEN_IO,   &
     &                                                          A_IO)
      IF(A_IO /= -1.0.OR.LEN_IO /= LEN1_LOOKUP*PP_LEN_MEAN) THEN
! DEPENDS ON: ioerror
        CALL IOERROR('Buffer out of LOOKUP table   ',A_IO,LEN_IO,       &
     &                LEN1_LOOKUP*PP_LEN_MEAN)
        CMESSAGE='MEANDIAG : Error writing PPfile LOOKUP table'
        ICODE=314
        GOTO 999
      ENDIF
      LEN_PPNAME=LEN(PPNAME)
! DEPENDS ON: file_close
      CALL FILE_CLOSE(PPUNIT,PPNAME,LEN_PPNAME,1,0,ICODE)
!L----------------------------------------------------------------------
!L 5. Construct mean PPfile processing requests and output to server
!L    This deals with both "normal" and section 21-24 etc period means
!L
      NFTPIPE = 8
      INDEXM = MEANLEV
#if defined(MPP)
      IF(mype == 0) THEN
#endif
      IF (I_AO == 1 .or. I_AO == 2) THEN
        IF (PPSELECTim(INDEXM,I_AO) == 1) THEN
          IF (ARCHPPSELim(INDEXM,I_AO) == 1) THEN
            WRITE(NFTPIPE,420) PPNAME       ! Archive without plotting
          ENDIF
          IF (MEANWSim(INDEXM,I_AO) == "Y") THEN
              WRITE(NFTPIPE,450) PPNAME       ! Transfer to workstation
          ENDIF
            IF (PPUNIT == 22.OR.PPUNIT == 42.OR.(PPUNIT >  59.AND.      &
     &        PPUNIT <  68).OR.PPUNIT == 27) THEN
              IF (FT_SELECT(PPUNIT) == "Y") THEN
                WRITE(NFTPIPE,440) PPNAME       ! Delete from Cray
              ENDIF
            ELSE
              WRITE(NFTPIPE,440) PPNAME       ! Delete from Cray
            ENDIF
        ENDIF
      ENDIF
#if defined(MPP)
      ENDIF
#endif
 410  FORMAT("%%% ",A14," ARCHIVE PPCHART")
 420  FORMAT("%%% ",A14," ARCHIVE PPNOCHART")
 430  FORMAT("%%% ",A14," PLOTONLY PPCHART")
 440  FORMAT("%%% ",A14," DELETE")
 450  FORMAT("%%% ",A14," HPSEND")
!L----------------------------------------------------------------------
 999  CONTINUE
       IF (MYPE == CURRENT_IO_PE) THEN
          NULLIFY(PP_FIXHD,PPLOOK)
       ELSE
          DEALLOCATE(PP_FIXHD,PPLOOK)
       END IF
      RETURN
      END SUBROUTINE MEANDIAG
#endif
